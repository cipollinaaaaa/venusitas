<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Venusian Gems</title>
  <style>
    body {
      background-color: #000;
      color: white;
      font-family: 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      overflow: hidden;
      min-height: 100vh;
      touch-action: none;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: none;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100vw;
      height: 100vh;
      box-sizing: border-box;
      padding: 10px;
      gap: 10px;
    }

    @media (min-width: 768px) {
      .game-container {
        flex-direction: row;
        padding: 20px;
        gap: 20px;
      }
    }

    .info-panel {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 15px;
      gap: 10px;
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      max-width: 240px;
      z-index: 100;
    }

    h1 {
      font-size: 2em;
      color: #00ffe7;
      text-shadow: 0 0 10px #00ffe7, 0 0 20px #00ffe7;
      margin: 0;
      white-space: nowrap;
    }

    .score-timer {
      display: none;
    }

    #timer {
      font-size: 1.4em;
      color: #ff0033;
      text-shadow: 0 0 5px #ff0033;
      font-weight: bold;
    }

    #resetButton {
      padding: 8px 16px;
      font-size: 1.1em;
      background-color: #ff0033;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
    }

    /* ‚úÖ CORREGIDO: Tablero con tama√±o m√°ximo seguro */
    #board {
      width: min(540px, 95vw);
      height: min(540px, 95vw);
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: min(5px, 1.5vw);
      position: relative;
      z-index: 0;
      overflow: hidden;
    }

    .cell {
      aspect-ratio: 1;
      border-radius: 16px;
      cursor: grab;
      transition: transform 0.2s ease-in-out, box-shadow 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: min(24px, 4.5vw);
      font-weight: bold;
      background: linear-gradient(145deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
      box-shadow:
        inset 0 0 8px rgba(255,255,255,0.4),
        inset 0 5px 12px rgba(0,0,0,0.3),
        0 2px 8px rgba(0,0,0,0.4);
      color: white;

      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .cell:hover {
      transform: scale(1.08);
      box-shadow:
        inset 0 0 10px rgba(255,255,255,0.6),
        0 0 15px #fff,
        0 0 30px #fff;
    }

    .cell:active {
      transform: scale(1.08);
      z-index: 100;
    }

    .red { background-color: #ff0033; }
    .yellow { background-color: #ffdd00; color: #333; }
    .green { background-color: #33cc33; }
    .pink { background-color: #ff66cc; }
    .purple { background-color: #aa33ff; }
    .orange { background-color: #ff8800; color: #333; }
    .aqua { background-color: #00cccc; }
    .venusian {
      background-image: url('venusian.png');
      background-size: cover;
      background-position: center;
      color: transparent !important;
    }
    .mano {
      background-image: url('mano.gif');
      background-size: cover;
      background-position: center;
      color: transparent !important;
    }

    #lightning {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      opacity: 0;
      pointer-events: none;
      z-index: 999;
    }

    .flash {
      animation: flashUp 0.2s forwards;
    }

    @keyframes flashUp {
      0% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    #messageOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.1), rgba(0,0,0,0.95));
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      backdrop-filter: blur(4px);
      flex-direction: column;
      text-align: center;
    }

    #messageOverlay h2 {
      font-size: 3em;
      color: #ff0;
      text-shadow: 0 0 10px #ff0, 0 0 20px #ff0, 0 0 30px #ff0;
      animation: blink 1s infinite;
      margin-bottom: 20px;
    }

    #messageOverlay .message-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    #messageOverlay img.message-img {
      width: 120px;
      height: auto;
      animation: float 2s infinite ease-in-out;
    }

    #messageOverlay button.message-reset-button {
      margin-top: 30px;
      padding: 12px 24px;
      font-size: 1.2em;
      background-color: #ff0033;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }

    #messageOverlay.game-over h2 {
        color: #ff0033;
        text-shadow: 0 0 10px #ff0033, 0 0 20px #ff0033, 0 0 30px #ff0033;
    }
  </style>
</head>
<body>

  <div class="game-container">
    <div class="info-panel">
      <h1>Venusian Gems</h1>
      <div class="score-timer" id="score">Score: 0</div>
      <div class="score-timer" id="timer">Time: 60</div>
      <button id="resetButton" onclick="resetGame()">üîÑ Reset</button>
    </div>
    
    <div id="board"></div>
  </div>

  <div id="lightning"></div>

  <audio id="matchSoundThree" src="venusci.mp3" preload="auto"></audio>
  <audio id="matchSoundFour" src="venusciously.mp3" preload="auto"></audio>
  <audio id="backgroundMusic" src="venusound.mp3" loop preload="auto"></audio>
  <audio id="winFanfareSound" src="venusliscious.mp3" preload="auto"></audio>
  <audio id="gameOverSound" src="loser.mp3" preload="auto"></audio>

  <div id="messageOverlay">
    <div class="message-content">
        <h2 id="messageTitle"></h2>
        <img id="messageImg1" src="" alt="" class="message-img">
        <img id="messageImg2" src="" alt="" class="message-img">
        <button class="message-reset-button" onclick="resetGame()">Play Again ‚û°Ô∏è</button>
    </div>
  </div>

  <script>
    const board = document.getElementById("board");
    const scoreDisplay = document.getElementById("score");
    const timerDisplay = document.getElementById("timer");
    const messageOverlay = document.getElementById("messageOverlay");
    const messageTitle = document.getElementById("messageTitle");
    const messageImg1 = document.getElementById("messageImg1");
    const messageImg2 = document.getElementById("messageImg2");
    const lightning = document.getElementById("lightning");

    const htmlMatchSoundThree = document.getElementById("matchSoundThree");
    const htmlMatchSoundFour = document.getElementById("matchSoundFour");
    const htmlBackgroundMusic = document.getElementById("backgroundMusic");
    const htmlWinFanfareSound = document.getElementById("winFanfareSound");
    const htmlGameOverSound = document.getElementById("gameOverSound");

    let gameLoop;
    let timerCountdown;
    let timeLeft = 60;
    let gameActive = false;

    const letterMap = {
      red: 'V', yellow: 'E', green: 'N', pink: 'U', purple: 'S', orange: 'I', aqua: 'A',
      venusian: 'N',
      mano: 'N'
    };

    const colors = ["red", "yellow", "green", "pink", "purple", "orange", "aqua", "venusian", "mano"];
    const boardSize = 8;
    const totalCells = boardSize * boardSize;
    let cells = [];
    let score = 0;

    let isDragging = false;
    let draggedCell = null;
    let targetCell = null;
    let touchDetected = false;

    function getGemColor(cell) {
      if (!cell) return null;
      for (const cls of cell.classList) {
        if (cls !== "cell" && colors.includes(cls)) {
          return cls;
        }
      }
      return null;
    }

    function setGemColor(cell, color) {
      const currentColor = getGemColor(cell);
      if (currentColor) {
        cell.classList.remove(currentColor);
      }
      if (color && colors.includes(color)) {
        cell.classList.add(color);
      }
      const text = (color && letterMap[color]) ? letterMap[color] : "";
      cell.textContent = text;
    }

    function createBoard() {
      cells = [];
      board.innerHTML = '';

      for (let i = 0; i < totalCells; i++) {
        const cell = document.createElement("div");
        cell.id = i;
        cell.classList.add("cell");

        const color = colors[Math.floor(Math.random() * colors.length)];
        setGemColor(cell, color);

        cell.addEventListener("touchstart", handleTouchStart, { passive: false });
        cell.addEventListener("touchmove", handleTouchMove, { passive: false });
        cell.addEventListener("touchend", handleTouchEnd);

        cell.addEventListener("mousedown", (e) => {
          if (!touchDetected) handleMouseDown(e);
        });

        board.appendChild(cell);
        cells.push(cell);
      }

      document.body.addEventListener("touchstart", handleFirstInteraction, { once: true, passive: false });
      document.body.addEventListener("mousedown", handleFirstInteraction, { once: true });
    }

    function handleFirstInteraction() {
      if (!gameActive) {
        gameActive = true;
        if (htmlBackgroundMusic) {
          htmlBackgroundMusic.play().catch(() => {});
        }
        startGameLoop();
      }
    }

    function handleTouchStart(e) {
      touchDetected = true;
      e.preventDefault();
      startDrag(e.touches[0], e.target);
    }

    function handleTouchMove(e) {
      if (!isDragging) return;
      e.preventDefault();
      moveDrag(e.touches[0]);
    }

    function handleTouchEnd() {
      endDrag();
    }

    function handleMouseDown(e) {
      startDrag(e, e.target);
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    }

    function handleMouseMove(e) {
      if (!isDragging) return;
      moveDrag(e);
    }

    function handleMouseUp() {
      endDrag();
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    }

    function startDrag(point, cell) {
      isDragging = true;
      draggedCell = cell;
      draggedCell.style.transform = "scale(1.08)";
      draggedCell.style.zIndex = "100";
      draggedCell.style.pointerEvents = "none";
    }

    function moveDrag(point) {
      const element = document.elementFromPoint(point.clientX, point.clientY);
      if (element && element.classList.contains("cell") && element !== draggedCell) {
        if (element !== targetCell) {
          if (targetCell) {
            targetCell.style.transform = "";
            targetCell.style.boxShadow = "";
          }
          targetCell = element;
          targetCell.style.transform = "scale(1.03)";
          targetCell.style.boxShadow = "0 0 12px #ffffff80";
        }
      } else if (targetCell) {
        targetCell.style.transform = "";
        targetCell.style.boxShadow = "";
        targetCell = null;
      }
    }

    function endDrag() {
      if (!isDragging) return;

      isDragging = false;
      draggedCell.style.transform = "";
      draggedCell.style.zIndex = "";
      draggedCell.style.pointerEvents = "";

      if (targetCell) {
        const id1 = parseInt(draggedCell.id);
        const id2 = parseInt(targetCell.id);

        const row1 = Math.floor(id1 / boardSize), col1 = id1 % boardSize;
        const row2 = Math.floor(id2 / boardSize), col2 = id2 % boardSize;
        const isAdjacent = (Math.abs(row1 - row2) === 1 && col1 === col2) || (Math.abs(col1 - col2) === 1 && row1 === row2);

        if (isAdjacent) {
          swapGems(id1, id2);
          checkMatchesAndRefill();
          checkWin();
        }

        targetCell.style.transform = "";
        targetCell.style.boxShadow = "";
        targetCell = null;
      }

      draggedCell = null;
    }

    function swapGems(id1, id2) {
      const color1 = getGemColor(cells[id1]);
      const color2 = getGemColor(cells[id2]);
      setGemColor(cells[id1], color2);
      setGemColor(cells[id2], color1);
    }

    function startGameLoop() {
      clearInterval(gameLoop);
      clearInterval(timerCountdown);

      timeLeft = 60;
      timerDisplay.textContent = `Time: ${timeLeft}`;

      gameLoop = setInterval(() => {
        if (gameActive) checkMatchesAndRefill();
      }, 200);

      timerCountdown = setInterval(() => {
        if (!gameActive) return;
        timeLeft--;
        timerDisplay.textContent = `Time: ${timeLeft}`;
        if (timeLeft <= 0) endGameByTime();
      }, 1000);
    }

    function collectMatches() {
      const matched = new Set();

      for (let row = 0; row < boardSize; row++) {
        for (let col = 0; col <= boardSize - 3; col++) {
          const i = row * boardSize + col;
          const c = getGemColor(cells[i]);
          if (!c) continue;
          if (getGemColor(cells[i+1]) === c && getGemColor(cells[i+2]) === c) {
            matched.add(i); matched.add(i+1); matched.add(i+2);
            if (col <= boardSize - 4 && getGemColor(cells[i+3]) === c) {
              matched.add(i+3);
              if (col <= boardSize - 5 && getGemColor(cells[i+4]) === c) {
                matched.add(i+4);
              }
            }
          }
        }
      }

      for (let col = 0; col < boardSize; col++) {
        for (let row = 0; row <= boardSize - 3; row++) {
          const i = row * boardSize + col;
          const c = getGemColor(cells[i]);
          if (!c) continue;
          if (getGemColor(cells[i + boardSize]) === c && getGemColor(cells[i + 2*boardSize]) === c) {
            matched.add(i); matched.add(i + boardSize); matched.add(i + 2*boardSize);
            if (row <= boardSize - 4 && getGemColor(cells[i + 3*boardSize]) === c) {
              matched.add(i + 3*boardSize);
              if (row <= boardSize - 5 && getGemColor(cells[i + 4*boardSize]) === c) {
                matched.add(i + 4*boardSize);
              }
            }
          }
        }
      }

      return Array.from(matched);
    }

    function checkMatchesAndRefill() {
      let matches = collectMatches();
      if (matches.length === 0) return false;

      if (matches.length >= 4) {
        htmlMatchSoundFour.currentTime = 0;
        htmlMatchSoundFour.play().catch(() => {});
      } else {
        htmlMatchSoundThree.currentTime = 0;
        htmlMatchSoundThree.play().catch(() => {});
      }

      matches.forEach(idx => {
        setGemColor(cells[idx], null);
        score += 10;
      });
      updateScore();

      moveGemsDown();
      return true;
    }

    function moveGemsDown() {
      for (let col = 0; col < boardSize; col++) {
        const gemsInColumn = [];
        for (let row = boardSize - 1; row >= 0; row--) {
          const idx = row * boardSize + col;
          const color = getGemColor(cells[idx]);
          if (color) {
            gemsInColumn.push(color);
          }
        }
        let gemIndex = 0;
        for (let row = boardSize - 1; row >= 0; row--) {
          const idx = row * boardSize + col;
          if (gemIndex < gemsInColumn.length) {
            setGemColor(cells[idx], gemsInColumn[gemIndex]);
            gemIndex++;
          } else {
            const newColor = colors[Math.floor(Math.random() * colors.length)];
            setGemColor(cells[idx], newColor);
          }
        }
      }
    }

    function updateScore() {
      scoreDisplay.textContent = "Score: " + score;
    }

    function checkWin() {
      const target = "VENUSIAN";
      for (let row = 0; row < boardSize; row++) {
        let str = "";
        for (let col = 0; col < boardSize; col++) {
          const c = getGemColor(cells[row * boardSize + col]);
          str += (c && letterMap[c]) ? letterMap[c] : "";
        }
        if (str.includes(target)) {
          showWinMessage();
          return;
        }
      }
      for (let col = 0; col < boardSize; col++) {
        let str = "";
        for (let row = 0; row < boardSize; row++) {
          const c = getGemColor(cells[row * boardSize + col]);
          str += (c && letterMap[c]) ? letterMap[c] : "";
        }
        if (str.includes(target)) {
          showWinMessage();
          return;
        }
      }
    }

    function showWinMessage() {
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);
      if (htmlBackgroundMusic) {
        htmlBackgroundMusic.pause();
        htmlBackgroundMusic.currentTime = 0;
      }
      messageTitle.textContent = "VENUSLICIOUS, you are Venusian People!!! üöÄ";
      messageImg1.src = "mano.gif";
      messageImg2.src = "venusian.png";
      messageOverlay.classList.remove('game-over');
      messageOverlay.style.display = "flex";
      htmlWinFanfareSound.currentTime = 0;
      htmlWinFanfareSound.play().catch(() => {});
    }

    function endGameByTime() {
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);
      if (htmlBackgroundMusic) {
        htmlBackgroundMusic.pause();
        htmlBackgroundMusic.currentTime = 0;
      }
      messageTitle.textContent = "¬°Se acab√≥ el tiempo! ¬°Game Over!";
      messageImg1.src = "mano.gif";
      messageImg2.src = "venusian.png";
      messageOverlay.classList.add('game-over');
      messageOverlay.style.display = "flex";
      htmlGameOverSound.currentTime = 0;
      htmlGameOverSound.play().catch(() => {});
    }

    function resetGame() {
      gameActive = false;
      clearInterval(gameLoop);
      clearInterval(timerCountdown);
      score = 0;
      updateScore();
      messageOverlay.style.display = "none";
      touchDetected = false;
      createBoard();
      if (htmlBackgroundMusic) {
        htmlBackgroundMusic.pause();
        htmlBackgroundMusic.currentTime = 0;
      }
    }

    // Iniciar
    createBoard();
  </script>
</body>
</html>